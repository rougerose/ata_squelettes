var Atlas = (function (exports) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var config = {
    modal: {
      zIndex: 7
    },
    markers: {
      size: {
        xs: 34,
        s: 44,
        m: 54,
        l: 64,
        xl: 74,
        xxl: 84
      }
    }
  };

  var init = function init(mapObj) {
    var map = new Map(mapObj);
  };
  var Map = /*#__PURE__*/function () {
    function Map(mapObj) {
      _classCallCheck(this, Map);

      this._map = mapObj;
      this._json = this._map.options.json_points; // Bug Leaflet : le click sur un marqueur est envoyé deux fois.
      // Solution provisoire : https://github.com/Leaflet/Leaflet/issues/7255

      L.Util.setOptions(this._map, {
        tap: false
      }); // Position du crédit carto...

      L.Control.Attribution.prototype.options.position = "bottomleft"; // ... et du zoom

      L.Control.Zoom.prototype.options.position = "bottomright"; // charger les données json

      this.loadJson(); // charger l'objet Modal dans la carte

      this._modal = L.control.modal({
        container: "Modal",
        position: "bottom"
      }).addTo(this._map);
    } // Fonction reprise et adaptée de loadData() API de GIS
    // mais il s'agit ici d'appeler un traitement spécifique des données json


    _createClass(Map, [{
      key: "loadJson",
      value: function loadJson() {
        if (typeof this._json !== "undefined" && this._json.url.length) {
          var args = {};
          jQuery.extend(true, args, this._json.env);
          args.objets = this._json.objets;

          if (typeof this._json.limit !== "undefined") {
            args.limit = this._json.limit;
          }

          var self = this;
          jQuery.getJSON(self._json.url, args, function (data) {
            if (data) {
              self.parseJson(data);
            }
          });
        }
      } // Adaptation de la fonction parseGeoJson de GIS
      // afin de personnaliser les clusters.

    }, {
      key: "parseJson",
      value: function parseJson(data) {
        if (!this._map.options.cluster) {
          parseJsonFeatures(data);
        } else {
          var options = this._map.options.clusterOptions;

          options.iconCreateFunction = function (cluster) {
            var size, variant, count;
            count = cluster.getChildCount();

            if (count <= 3) {
              variant = "-xs";
              size = config.markers.size.xs;
            } else if (count <= 10) {
              variant = "-s";
              size = config.markers.size.s;
            } else if (count <= 50) {
              variant = "-m";
              size = config.markers.size.m;
            } else if (count <= 100) {
              variant = "-l";
              size = config.markers.size.l;
            } else if (count <= 250) {
              variant = "-xl";
              size = config.markers.size.xl;
            } else {
              variant = "-xxl";
              size = config.markers.size.xxl;
            }

            return new L.DivIcon({
              html: "<div><span>" + count + "</span></div>",
              className: "mp-MarkerCluster mp-MarkerCluster" + variant,
              iconSize: new L.Point(size, size)
            });
          };

          this._map.markerCluster = L.markerClusterGroup(options).addTo(this._map);
          var markers = [];
          var autres = {
            type: "FeatureCollection",
            features: []
          };

          for (var index = 0; index < data.features.length; index++) {
            var feature = data.features[index];

            if (feature.geometry.type == "Point" && feature.geometry.coordinates[0]) {
              var marker = L.marker([feature.geometry.coordinates[1], feature.geometry.coordinates[0]]); // Déclarer l'icone du point en utilisant l'API GIS

              this._map.setGeoJsonFeatureIcon(feature, marker); // Gérer le click


              this._clickMarker(marker, "on");

              marker.feature = feature;
              markers.push(marker);
            } else {
              autres.features.push(feature);
            }
          }

          this._map.markerCluster.addLayers(markers);

          this.parseJsonFeatures(autres);
        }
      }
    }, {
      key: "parseJsonFeatures",
      value: function parseJsonFeatures(data) {
        if (data.features && data.features.length > 0) {
          var self = this;
          var geojson = L.geoJson("", {
            style: self._map.options.pathStyles ? self._map.options.pathStyles : function (feature) {
              if (feature.properties && feature.properties.styles) {
                return feature.properties.styles;
              } else {
                return "";
              }
            },
            onEachFeature: function onEachFeature(feature, layer) {
              // Icone du point
              if (feature.geometry.type == "Point") {
                self._map.setGeoJsonFeatureIcon(feature, layer);
              }
            },
            pointToLayer: function pointToLayer(feature, latlng) {
              var alt = "Marker";

              if (feature.properties.title) {
                alt = feature.properties.title;
              }

              var marker = L.marker(latlng, {
                alt: alt
              }); // click

              return marker;
            }
          }).addData(data).addTo(self._map);

          if (self._map.options.autocenterandzoom) {
            var options = {
              maxZoom: 10
            };

            self._map.fitBounds(geojson.getBounds(), options);
          }

          if (typeof self._map.geojsons == "undefined") {
            self._map.geojsons = [];
          }

          self._map.geojsons.push(geojson);
        }
      } // Pour éviter un temps de chargement très long de la carte,
      // lors du premier chargement des données,
      // chaque marqueur ne contient que les données "associations"
      // (nom, site, logo). Il s'agit donc ici de collecter
      // le complément d'informations nécessaire : adresse, réseaux sociaux, activités.
      // Puis d'ouvrir la fenêtre modale de consultation des infos de l'association.

    }, {
      key: "onClickMarker",
      value: function onClickMarker(eventObj) {
        var map = this;
        var args = {
          objets: "association",
          id_association: eventObj.target.feature.properties.id_association
        };
        jQuery.getJSON(map._json.url, args, function (data) {
          if (data && data.features.length == 1) {
            var modal = map._modal;
            modal.open(data.features[0]);
          }
        });
      }
    }, {
      key: "_clickMarker",
      value: function _clickMarker(marker, on) {
        if (on === "on") {
          L.DomEvent.on(marker, "click", this.onClickMarker, this);
        } else {
          // console.log("_clickMarker off", on);
          L.DomEvent.off(marker, "click", this.onClickMarker, this);
        }
      }
    }, {
      key: "handler",
      value: function handler(event) {// console.log(this, event);
        // let map = this;
        // map.body.removeEventListener("transitionend", map.handler.bind(map, event.target));
        // this.body.removeEventListener("transitionend", map.handler.bind(map, event.target));
      }
    }]);

    return Map;
  }();

  exports.Map = Map;
  exports.init = init;

  return exports;

}({}));
