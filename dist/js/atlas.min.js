var atlas = (function (exports) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var config = {
    windowBreakpoint: 768,
    markerSize: {
      xs: 34,
      s: 44,
      m: 54,
      l: 64,
      xl: 74,
      xxl: 84
    },
    searchBox: {
      containerId: "SearchBox",
      btnAdvancedId: "#openAdvancedSearch",
      panelClassName: "mp-SearchBox_Panel"
    },
    keywords: {
      containerClassName: "mp-Keywords-toSelect",
      ulClassName: "mp-Keywords_List",
      liClassName: {
        main: "mp-Keywords_Item",
        variant: "mp-Keywords_Item-selected"
      },
      labelClassName: "mp-Keywords_Label",
      btnDeleteClassName: "mp-Keywords_BtnDelete",
      tooltipClassName: "mp-Keywords_BtnTooltip",
      activities: {
        liClassName: "mp-Keywords_Item-toSelect",
        aClassName: "mp-Keywords_Label-activity"
      }
    },
    queryKeywords: {
      containerId: "js-Keywords"
    },
    modal: {
      setTabIndex: true,
      openedClass: "is-opened",
      closedClass: "is-closed",
      bottomBarClass: "mp-Modal_Bar",
      containerId: "Modal",
      btnClassName: "mp-Modal_BtnAction",
      headerClassName: "mp-Modal_HeaderContent",
      bodyClassName: "mp-Modal_Body",
      profile: {
        headerClassName: "mp-OrgProfile_Header",
        badge: {
          imgClassName: "mp-OrgProfile_Logo",
          figClassName: "mp-OrgProfile_Badge"
        },
        nameClassName: "mp-OrgProfile_Name"
      }
    }
  };

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now = function () {
    return _root.Date.now();
  };

  var now_1 = now;

  /** Built-in value references. */

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol;

  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;

  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max,
      nativeMin = Math.min;
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */

  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber_1(wait) || 0;

    if (isObject_1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now_1();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now_1());
    }

    function debounced() {
      var time = now_1(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce;

  /*eslint no-fallthrough: "off"*/
  const callbackEvents = ['hide', 'show'];
  /**
   * Tablist constructor
   * @constructor
   * @param {Node} el - DOM node
   */

  class Tablist {
    constructor(el) {
      if (!el || !el.nodeName) {
        throw new Error('No DOM node provided. Abort.');
      }

      this.el = el;
      this._tablist = {};
      this._callbacks = {};
      this._handleDisplay = this._handleDisplay.bind(this);
      this._handleFocus = this._handleFocus.bind(this);
      this._handleTab = this._handleTab.bind(this);
      this._handlePanelFocus = this._handlePanelFocus.bind(this);
      this._handlePanel = this._handlePanel.bind(this);
    }
    /**
     * Retrieve first activable tab (that does not have `disabled` attribute)
     */


    _firstActiveTab() {
      let activeTab;

      for (let i = 0; i < this._tablist.tabs.length; i++) {
        if (!this._tablist.tabs[i].disabled) {
          activeTab = i;
          break;
        }
      }

      return activeTab;
    }
    /**
     * Toggle display of the tabPanel (show/hide)
     * @param {DOMEvent} e - Can be a `MouseEvent` or a `KeyboardEvent` object
     */


    _handleDisplay(e) {
      e.preventDefault();
      const tab = e.currentTarget;

      if (tab.disabled) {
        return;
      } // ensure the tab has the focus when a click occurs


      if (tab !== document.activeElement) {
        tab.focus();
      }

      this._toggleDisplay(this._tablist.tabs.indexOf(tab));
    }
    /**
     * Update the current tab index before selecting the current tab
     * @param {DOMEvent} e - A `FocusEvent` object
     */


    _handleFocus(e) {
      const tab = e.currentTarget;

      if (tab.disabled) {
        return;
      }

      this._tablist.currentTabIndex = this._tablist.tabs.indexOf(tab);

      this._select(this._tablist.tabs[this._tablist.currentTabIndex]);
    }
    /**
     * Handle keystroke on [role=tabpanel]
     * @param {DOMEvent} e - A `KeyboardEvent` object
     */


    _handlePanel(e) {
      if (this._tablist.currentTabIndex === undefined) {
        this._handlePanelFocus(e);
      }

      switch (e.keyCode) {
        // ctrl + page up
        case 33:
          if (e.ctrlKey) {
            e.preventDefault(); // focus the previous tab

            this._switchTab(this._tablist.currentTabIndex - 1);
          }

          break;
        // ctrl + page down

        case 34:
          if (e.ctrlKey) {
            e.preventDefault(); // focus the next tab

            this._switchTab(this._tablist.currentTabIndex + 1);
          }

          break;
        // focus back to tab
        // ctrl + up

        case 38:
          if (e.ctrlKey) {
            e.preventDefault(); // focus linked tab

            this._switchTab(this._tablist.currentTabIndex);
          }

          break;
      }
    }
    /**
     * Ensure that the current tab index is the one matching the tabPanel
     * @param {DOMEvent} e - A `FocusEvent` or `KeyboardEvent` object
     */


    _handlePanelFocus(e) {
      if (e.target.doubleFocus) {
        e.preventDefault();
        delete e.target.doubleFocus;
        return;
      }

      const tabPanel = e.currentTarget;
      this._tablist.currentTabIndex = this._tablist.tabPanels.indexOf(tabPanel); // prevent double focus event when the inputs are focused

      if (['radio', 'checkbox'].indexOf(e.target.type) >= 0) {
        e.target.doubleFocus = true;
      }
    }
    /**
     * Handle keystroke on [role=tab]
     * @param {DOMEvent} e - A `KeyboardEvent` object
     */


    _handleTab(e) {
      if (this._tablist.currentTabIndex === undefined) {
        this._handleFocus(e);
      }

      switch (e.keyCode) {
        // space
        case 32: // return

        case 13:
          // toggle the display of the linked tabpanel
          this._handleDisplay(e);

          break;
        // end

        case 35:
          e.preventDefault(); // focus the last tab

          this._switchTab(this._tablist.tabs.length - 1);

          break;
        // home

        case 36:
          e.preventDefault(); // focus the first active tab

          this._switchTab(this._firstActiveTab());

          break;
        // left

        case 37: // up

        case 38:
          e.preventDefault(); // focus the previous tab

          this._switchTab(this._tablist.currentTabIndex - 1);

          break;
        // right

        case 39: // down

        case 40:
          e.preventDefault(); // focus the next tab

          this._switchTab(this._tablist.currentTabIndex + 1);

          break;
      }
    }
    /**
     * Dummy function
     */


    _noop() {}
    /**
     * Update tab selected attributes (`aria-selected`, `tabindex`)
     * based on the `tabToSelect` attribute
     * @param {DOMElement} tabToSelect - Tab element to select
     */


    _select(tabToSelect) {
      // loop on each tab
      this._tablist.tabs.forEach((tab, index) => {
        const shouldSelect = tabToSelect === tab;
        tab.setAttribute('aria-selected', shouldSelect);
        tab.setAttribute('tabindex', shouldSelect ? 0 : -1); // only for tab to be selected

        if (shouldSelect) {
          this._toggleDisplay(index);
        }
      });
    }
    /**
     * Move the focus to the tab based on the index
     * @param {number} index - Index of the element to focus
     */


    _switchTab(index) {
      // handle disabled tab
      if (this._tablist.tabs[index] && this._tablist.tabs[index].disabled) {
        // cycling forward? Then go one item farther
        const newIndex = index > this._tablist.currentTabIndex ? index + 1 : index - 1;

        this._switchTab(newIndex);

        return;
      }

      this._tablist.currentTabIndex = index;

      if (this._tablist.currentTabIndex < this._firstActiveTab()) {
        this._tablist.currentTabIndex = this._tablist.tabsLength - 1;
      } else if (this._tablist.currentTabIndex >= this._tablist.tabsLength) {
        this._tablist.currentTabIndex = this._firstActiveTab();
      }

      this._tablist.tabs[this._tablist.currentTabIndex].focus();
    }
    /**
     * Toggle the `aria-hidden` attribute on the tabpanel based on the passed tab
     * @param {integer} index - index of the tab
     * @param {boolean} show - whether or not display the panel
     */


    _toggleDisplay(index, show = true) {
      if (show && index === this._tablist.openedIndex) {
        return;
      }

      const tab = this._tablist.tabs[index];
      const tabPanel = this._tablist.tabPanels[index]; // close the previous tab

      if (show && this._tablist.openedIndex !== undefined) {
        this._toggleDisplay(this._tablist.openedIndex, false);
      }

      tabPanel.setAttribute('aria-hidden', !show);

      if (show) {
        this._tablist.openedIndex = index;

        if (this._tablist.openedIndex !== undefined) {
          this._trigger('show', [tab, tabPanel]);
        }
      } else if (this._tablist.openedIndex !== undefined) {
        this._trigger('hide', [tab, tabPanel]);
      }
    }

    _trigger(eventName, params) {
      if (!this._callbacks[eventName]) {
        return;
      }

      this._callbacks[eventName].forEach(callback => {
        callback.apply(this, params);
      });
    }
    /**
     * Parse tablist element to setup the tab and tabpanel elements
     */


    mount() {
      let firstTabIndex; // create reference arrays

      this._tablist.tabs = [];
      this._tablist.tabPanels = []; // loop on each tab elements to find tabpanel elements and update their attributes

      Array.from(this.el.querySelectorAll('[role=tab]')).forEach((tab, index) => {
        const controls = tab.getAttribute('aria-controls');
        let tabPanel;
        let openedTab = false; // get the tabpanel linked to the tab element

        if (controls) {
          tabPanel = document.getElementById(controls);
        } else if (tab.nextElementSibling && tab.nextElementSibling.getAttribute('aria-labelledby') === tab.id) {
          tabPanel = tab.nextElementSibling;
        }

        if (!tabPanel) {
          throw new Error(`Could not find associated tabpanel for tab ${tab.id}. Use [aria-controls="tabpanelId"] on the [role="tab"] element to link them together`);
        } // store the tab and the tabpanel on their respective arrays on the tablist


        this._tablist.tabs.push(tab);

        this._tablist.tabPanels.push(tabPanel);

        tab.disabled = tab.hasAttribute('disabled') || tab.getAttribute('aria-disabled') === 'true'; // if there's no opened tab yet

        if (tab.getAttribute('data-open') === 'true' && !tab.disabled) {
          if (this._tablist.openedIndex === undefined) {
            this._toggleDisplay(index, true);

            openedTab = true;
          }
        } // remove setup data attributes


        tab.removeAttribute('data-open'); // get first non-disabled tab

        if (firstTabIndex === undefined && !tab.disabled) {
          firstTabIndex = index;
        } // set the attributes according the the openedTab status


        tab.setAttribute('tabindex', -1);
        tabPanel.setAttribute('aria-hidden', !openedTab); // subscribe internal events for tab and tap panel

        tab.addEventListener('click', this._handleDisplay);
        tab.addEventListener('focus', this._handleFocus);
        tab.addEventListener('keydown', this._handleTab);
        tabPanel.addEventListener('focus', this._handlePanelFocus, true);
        tabPanel.addEventListener('keydown', this._handlePanel);
      }); // store constants

      this._tablist.tabsLength = this._tablist.tabs.length;
      this._tablist.tabPanelsLength = this._tablist.tabPanels.length; // set the tabindex so the first opened tab or the first non-disabled tab can be focused on tab navigation

      if (this._tablist.openedIndex !== undefined) {
        this._tablist.tabs[this._tablist.openedIndex].setAttribute('tabindex', 0);

        this._tablist.tabs[this._tablist.openedIndex].setAttribute('aria-selected', 'true');
      } // if there's no opened tab and it's not an accordion open the first tab
      else {
          this._toggleDisplay(firstTabIndex, true);

          this._tablist.tabs[firstTabIndex].setAttribute('tabindex', 0);

          this._tablist.tabs[firstTabIndex].setAttribute('aria-selected', 'true');
        }
    }

    off(event, callback) {
      if (!this._callbacks[event]) {
        return;
      }

      const callbackIndex = this._callbacks[event].indexOf(callback);

      if (callbackIndex < 0) {
        return;
      }

      this._callbacks[event].splice(callbackIndex, 1);
    }

    on(event, callback) {
      if (callbackEvents.indexOf(event) < 0) {
        return;
      }

      if (!this._callbacks[event]) {
        this._callbacks[event] = [];
      }

      this._callbacks[event].push(callback);
    }
    /**
     * Returns the opened tab or array of opened tabs
     */


    get current() {
      const tab = this._tablist.tabs[this._tablist.openedIndex];
      const tabPanel = this._tablist.tabPanels[this._tablist.openedIndex];
      return {
        tab,
        tabPanel
      };
    }
    /**
     * unbind tablist
     */


    unmount() {
      this._tablist.tabs.forEach((tab, index) => {
        const tabPanel = this._tablist.tabPanels[index]; // unsubscribe internal events for tab and tap panel

        tab.removeEventListener('click', this._handleDisplay);
        tab.removeEventListener('focus', this._handleFocus);
        tab.removeEventListener('keydown', this._handleTab);
        tab.removeAttribute('tabindex');
        tab.removeAttribute('aria-selected');
        tabPanel.removeEventListener('focus', this._handlePanelFocus, true);
        tabPanel.removeEventListener('keydown', this._handlePanel);
        tabPanel.setAttribute('aria-hidden', 'false');
      });

      this._tablist = {};
    }

  }

  var AtlasBase = /*#__PURE__*/function () {
    function AtlasBase(map, state, conf) {
      var _this = this;

      _classCallCheck(this, AtlasBase);

      this.map = map;
      this.configMap(); // Ajouter gestionnaire sur window.onresize

      this.handleResize = this._handleResize.bind(this);
      window.addEventListener("resize", debounce_1(this.handleResize, 250));
      var container = document.getElementById(conf.containerId);
      var dispatch = conf.dispatch;
      var controls = conf.controls;
      this.state = state;
      this.dispatch = dispatch;
      this.container = container;
      this.memory = {}; // Activer les modules "controls"

      this.controls = {};
      controls.forEach(function (Control) {
        _this.controls[Control.name] = new Control(state, {
          container: container,
          dispatch: dispatch
        });
      }); // Activer Tablist @accede-web/tablist

      var list = this.container.querySelector("#Tab ul[role='tablist']");

      if (list) {
        var tablist = new Tablist(list);
        tablist.mount();
      }
    }

    _createClass(AtlasBase, [{
      key: "configMap",
      value: function configMap() {
        var _this2 = this;

        // Bug Leaflet : le click sur un marqueur est envoyé deux fois. Solution provisoire :
        // désactiver l'option "tap" : https://github.com/Leaflet/Leaflet/issues/7255
        L.Util.setOptions(this.map, {
          tap: false
        }); // Position du crédit carto...

        L.Control.Attribution.prototype.options.position = "bottomleft"; // ... et du zoom

        L.Control.Zoom.prototype.options.position = "bottomright"; // Ajouter un gestionnaire de click sur chaque marqueur, mais après "ready"
        // car le module est chargé lors de l'événement "load" et les marqueurs
        // ne sont pas encore disponibles.

        var onready = function onready() {
          _this2._handleClickMarker(); // jQuery("#" + this.map._container.id).off("ready", onready);

        };

        jQuery("#" + this.map._container.id).on("ready", onready); // Personnaliser les icones des clusters

        if (this.map.options.cluster) {
          this.map.options.clusterOptions.iconCreateFunction = this.clusterIcon;
        }
      } // Clusters personnalisés

    }, {
      key: "clusterIcon",
      value: function clusterIcon(cluster) {
        var SIZE = config.markerSize;
        var size, variant, count;
        count = cluster.getChildCount();

        if (count <= 3) {
          variant = "-xs";
          size = SIZE.xs;
        } else if (count <= 10) {
          variant = "-s";
          size = SIZE.s;
        } else if (count <= 50) {
          variant = "-m";
          size = SIZE.m;
        } else if (count <= 100) {
          variant = "-l";
          size = SIZE.l;
        } else if (count <= 250) {
          variant = "-xl";
          size = SIZE.xl;
        } else {
          variant = "-xxl";
          size = SIZE.xxl;
        }

        return new L.DivIcon({
          html: "<div><span>" + count + "</span></div>",
          className: "mp-MarkerCluster mp-MarkerCluster" + variant,
          iconSize: new L.Point(size, size)
        });
      }
    }, {
      key: "syncState",
      value: function syncState(state) {
        if (state.keywordsSelected.size !== this.state.keywordsSelected.size) {
          if (state.keywordsSelected.size !== 0) {
            this.searchCollection(state.keywordsSelected);
            this.state = state;
          } else {
            // recharger la carte dans son état initial
            this.resetMap();
            this.state = state;
          }
        }

        if (Object.keys(state.centerMarker).length > 0) {
          this.centerOnMarker(state.centerMarker.coords, state.centerMarker.id);
        }

        if (state.moveZoom !== "") {
          this.moveZoom(state.moveZoom);
        }

        this.state = state;

        for (var key in this.controls) {
          this.controls[key].syncState(state);
        }
      } // Compléter les variables state nécessaires.
      // La fonction est appelée depuis atlas.init()

    }, {
      key: "setInitialState",
      value: function setInitialState() {
        if (!this.state.windowWidth) {
          this.dispatch({
            type: "updateWindowWidth",
            windowWidth: this._getWindowWidth()
          });
        }

        if (!this.state.searchboxHeight) {
          this.dispatch({
            type: "updateSearchboxHeight",
            searchboxHeight: this.controls.SearchBox._getHeight()
          });
        }
      }
    }, {
      key: "_handleResize",
      value: function _handleResize(event) {
        // resize : vérifier si la largeur de la fenêtre a changé
        this._checkWindowWidth();
      }
    }, {
      key: "_handleClickMarker",
      value: function _handleClickMarker() {
        var self = this;
        var markers = {};

        var cb = function cb(event) {
          self.dispatch({
            type: "addModalContent",
            openId: this.feature.id,
            modalId: "modalAssociation"
          });
          self.dispatch({
            type: "centerOnMarker",
            coords: this.feature.geometry.coordinates,
            id: this.feature.id
          });
        };

        this.map.markerCluster.eachLayer(function (layer) {
          // garder en mémoire les markers afin de pouvoir les réutiliser
          markers[layer.id] = layer;
          layer.on("click", cb);
        });
        this.memory.markers = markers;
      }
    }, {
      key: "_getWindowWidth",
      value: function _getWindowWidth() {
        var breakpoint = config.windowBreakpoint;
        var windowWidth = window.innerWidth >= breakpoint ? "desktop" : "mobile";
        return windowWidth;
      }
    }, {
      key: "_checkWindowWidth",
      value: function _checkWindowWidth() {
        var currentWidth = this._getWindowWidth();

        if (this.state.windowWidth !== currentWidth) {
          this.dispatch({
            type: "updateWindowWidth",
            windowWidth: currentWidth
          });
        }
      }
    }, {
      key: "handleAction",
      value: function handleAction(state, action) {
        // Corriger un écart entre les listes de mots-clés.
        // La liste keywords est celle qui est à jour
        // (en l'occurence qu'il n'y a plus aucun mot-clé sélectionné).
        if (state.keywords.size == 0 && state.keywordsSelected.size > 0) {
          state.keywordsSelected = new Map();
        } // Conserver en mémoire l'état actuel, et le distribuer à tous les
        // modules enfants, sauf celui relatif aux modales qui est temporaire.


        var currentState = this.state;
        currentState.modalAction = "";
        currentState.modalArgs = {};
        currentState.modalOpenId = "";
        currentState.modalId = "";
        currentState.centerMarker = {};
        currentState.moveZoom = "";
        var keywords;
        var keywordsSelected;

        switch (action.type) {
          case "addKeyword":
            keywords = new Map(state.keywords);
            keywordsSelected = new Map(state.keywordsSelected);
            keywords.set(action.keyword.value, action.keyword.label);
            keywordsSelected.set(action.keyword.value, action.keyword.label);
            state = Object.assign({}, currentState, {
              keywords: keywords,
              keywordsSelected: keywordsSelected
            });
            break;

          case "removeKeywordSelected":
            keywords = new Map(state.keywords);
            keywordsSelected = new Map(state.keywordsSelected);
            keywords.delete(action.keyword.value);
            keywordsSelected.delete(action.keyword.value);
            state = Object.assign({}, currentState, {
              keywords: keywords,
              keywordsSelected: keywordsSelected
            });
            break;

          case "addModalContent":
            action.action = "addModalContent";
            action.modalId = action.modalId;
            action.openId = action.openId || "";
            action.args = action.args || {};
            state = Object.assign({}, currentState, {
              modalAction: action.action,
              modalOpenId: action.openId,
              modalArgs: action.args,
              modalId: action.modalId
            });
            break;

          case "updateModalPosition":
            action.action = action.action || "";
            action.modalId = action.modalId || "";
            action.openId = action.openId || "";
            action.args = action.args || {};
            state = Object.assign({}, currentState, {
              modalAction: action.action,
              modalOpenId: action.openId,
              modalArgs: action.args,
              modalId: action.modalId
            });
            break;

          case "updateWindowWidth":
            state = Object.assign({}, currentState, {
              windowWidth: action.windowWidth
            });
            break;

          case "updateSearchboxHeight":
            if (!action.searchboxHeight) {
              action.searchboxHeight = this.controls.SearchBox._getHeight();
            }

            state = Object.assign({}, currentState, {
              searchboxHeight: action.searchboxHeight
            });
            break;

          case "centerOnMarker":
            state = Object.assign({}, currentState, {
              centerMarker: {
                coords: action.coords,
                id: action.id
              }
            });
            break;

          case "moveZoom":
            state = Object.assign({}, currentState, {
              moveZoom: action.height
            });
            break;
        }

        return state;
      }
    }, {
      key: "autocompleteAddKeyword",
      value: function autocompleteAddKeyword(keyword) {
        this.dispatch({
          type: "addKeyword",
          keyword: keyword
        });
      }
    }, {
      key: "centerOnMarker",
      value: function centerOnMarker(coords, id) {
        // const latLngs = L.GeoJSON.coordsToLatLng(coords);
        var marker = this.memory.markers[id]; // console.log(latLngs);

        this.map.markerCluster.zoomToShowLayer(marker, function () {
          marker.openPopup();
        }); // this.map.markerCluster.eachLayer((layer) => {
        //     if (layer.id == id) {
        //        this.map.markerCluster.zoomToShowLayer(layer, function () {});
        //    }
        // });
        // this.map.setView(latLngs);
        // const latLngs = [ L.GeoJSON.coordsToLatLng(coords) ];
        // const bounds = L.latLngBounds(latLngs);
        // this.map.fitBounds(bounds, {maxZoom: 10});
      }
    }, {
      key: "moveZoom",
      value: function moveZoom(height) {
        var zoomControl = this.map.zoomControl.getContainer();
        zoomControl.style.transform = "translateY(" + height + "px)";
      }
    }, {
      key: "resetMap",
      value: function resetMap() {
        this.map.removeAllMarkers();
        this.map.loadData();
        this.dispatch({
          type: "updateModalPosition",
          action: "closeModals"
        });
      }
    }, {
      key: "createQuery",
      value: function createQuery(keywords) {
        var query = {
          id_association: [],
          id_mot: [],
          id_adresse: [],
          limit: this.map.options.json_points.limit
        }; // la syntaxe key est la forme suivante : "id_objet_spip:identifiant_numerique"

        var _iterator = _createForOfIteratorHelper(keywords),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 1),
                key = _step$value[0];

            var objet_spip = key.split(":");
            var index = query[objet_spip[0]].length;
            query[objet_spip[0]][index] = objet_spip[1];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return query;
      }
    }, {
      key: "searchCollection",
      value: function searchCollection(keywords) {
        var self = this;
        var map = self.map;
        var URL = "http.api/collectionjson/associations";
        var query = self.createQuery(keywords);
        query = jQuery.param(query);
        var collection = jQuery.getJSON(URL, query);
        collection.done(function (json) {
          var associations = {
            id_association: []
          };
          var items = json.collection.items;

          for (var key in items) {
            if (Object.hasOwnProperty.call(items, key)) {
              associations.id_association.push(items[key].data[0].value);
            }
          }

          var args = {};
          jQuery.extend(true, args, map.options.json_points.env, associations);
          args.objets = "associations_recherche";
          args.limit = map.options.json_points.limit;
          self.searchFeatures(map.options.json_points.url, args);
        });
        collection.fail(function (jqxhr, textStatus, error) {
          var err = textStatus + ", " + error; // TODO gestion erreur

          console.log("Request Failed: " + err);
        });
      }
    }, {
      key: "searchFeatures",
      value: function searchFeatures(url, args) {
        var self = this;
        var map = self.map;
        jQuery.getJSON(url, args, function (data) {
          if (data) {
            map.removeAllMarkers(); // map.options.autocenterandzoom = true;

            map.parseGeoJson(data);
            jQuery("#" + map._container.id).trigger("ready", map);
            self.dispatch({
              type: "addModalContent",
              args: args,
              modalId: "modalRecherche"
            });
          }
        });
      }
    }]);

    return AtlasBase;
  }();

  var SearchBox = /*#__PURE__*/function () {
    function SearchBox(state, _ref) {
      var container = _ref.container,
          dispatch = _ref.dispatch;

      _classCallCheck(this, SearchBox);

      this.state = state;
      this._container = container.querySelector("#SearchBox");
      this._advancedSearchIsOpen = false;
      this.dispatch = dispatch;

      this._initLayout(this._container);
    }

    _createClass(SearchBox, [{
      key: "_getHeight",
      value: function _getHeight() {
        return this._container.offsetHeight;
      }
    }, {
      key: "updateHeight",
      value: function updateHeight(value) {
        var height = value || this._getHeight();

        this.dispatch({
          type: "updateSearchboxHeight",
          searchboxHeight: height
        });
      }
    }, {
      key: "_initLayout",
      value: function _initLayout(container) {
        var _this = this;

        // Inputs text
        this._inputs = container.querySelectorAll("input[type=text]");
        [].forEach.call(this._inputs, function (input) {
          input.addEventListener("focus", _this._handlerInputEvent);
          input.addEventListener("blur", _this._handlerInputEvent);
        }); // Cancel Buttons (formulaires)

        this._cancelBtns = container.querySelectorAll("button[type=reset]");
        [].forEach.call(this._cancelBtns, function (cancelBtn) {
          var uid = cancelBtn.dataset.relId;
          var input = container.querySelector("[data-id='" + uid + "']");
          cancelBtn.addEventListener("click", _this._onclickCancelBtn.bind(input));
        }); // Advanced Search button

        this._advancedSearchBtn = container.querySelector(config.searchBox.btnAdvancedId);

        this._advancedSearchBtn.addEventListener("click", function () {
          _this._togglePanels();
        }); // Panels fulltext/advanced


        this._panels = container.querySelectorAll("." + config.searchBox.panelClassName);

        if (!this._advancedSearchIsOpen) {
          for (var index = 0; index < this._panels.length; index++) {
            var panel = this._panels[index];

            if (index == 0) {
              panel.setAttribute("aria-hidden", "false");
            } else {
              panel.setAttribute("aria-hidden", "true");
            }
          }
        }
      }
    }, {
      key: "_togglePanels",
      value: function _togglePanels() {
        // Quel panneau doit être affiché ?
        var panelToShow = this._advancedSearchIsOpen ? 0 : 1;

        if (this._advancedSearchIsOpen) {
          // Fermer (état initial)
          this._advancedSearchBtn.setAttribute("aria-expanded", "false");

          this._advancedSearchIsOpen = false;
        } else {
          // Ouvrir
          this._advancedSearchBtn.setAttribute("aria-expanded", "true");

          this._advancedSearchIsOpen = true;
        } // sélectionner le panneau à fermer


        var closePanel = this._panels[1 - panelToShow]; // et celui à ouvrir

        var openPanel = this._panels[panelToShow];
        this.close(closePanel);
        this.open(openPanel);
      }
    }, {
      key: "close",
      value: function close(panel) {
        panel.setAttribute("aria-hidden", "true");
      }
    }, {
      key: "open",
      value: function open(panel) {
        panel.setAttribute("aria-hidden", "false");
        this.updateHeight();
      }
    }, {
      key: "_handlerInputEvent",
      value: function _handlerInputEvent(event) {
        var parentElement = this.offsetParent;

        if (event.type === "focus") {
          parentElement.classList.add("is-focused");
        } else if (event.type === "blur" && event.target.value === "") {
          parentElement.classList.remove("is-focused");
        }
      }
    }, {
      key: "_onclickCancelBtn",
      value: function _onclickCancelBtn(event) {
        event.preventDefault();
        var input = this;
        input.value = null;
        input.offsetParent.classList.remove("is-focused");
      }
    }, {
      key: "syncState",
      value: function syncState(state) {
        this.state = state;
      }
    }]);

    return SearchBox;
  }();

  var Keyword = /*#__PURE__*/function () {
    function Keyword(state, _ref) {
      var container = _ref.container,
          dispatch = _ref.dispatch;

      _classCallCheck(this, Keyword);

      this.state = state;
      this.dispatch = dispatch;
      this.container = container.querySelector("#Keyword"); // listbox

      this.listbox = container.querySelector("#listBox");
      this.options = {
        prevKeys: 37,
        nextKeys: 39
      };

      this._setupOptions(this.options);

      this._handleClick = this._handleClick.bind(this);
      this._handleKeydown = this._handleKeydown.bind(this);

      this._mount();
    }

    _createClass(Keyword, [{
      key: "syncState",
      value: function syncState(state) {
        if (state.keywords.size !== this.state.keywords.size) {
          if (state.keywords.size === 0) {
            // Supprimer toute la sélection
            this._clearTabIndexes();

            this._clearAllSelectedItems();

            this.state.keywords = state.keywords;
          } else {
            // Supprimer, mais sélectionner à nouveau l'éventuel mot-clé
            // qui appartient à la liste gérée par ce module.
            this._clearTabIndexes();

            this._clearAllSelectedItems(); // mettre à jour state pour éviter une boucle sans fin.


            this.state.keywords = state.keywords;

            var _iterator = _createForOfIteratorHelper(state.keywords),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _step$value = _slicedToArray(_step.value, 1),
                    key = _step$value[0];

                var item = this.listbox.querySelector('li[data-value="' + key + '"]'); // Le mot-clé à ajouter n'appartient pas nécessairement à la liste gérée par ce modèle.

                if (item) {
                  this._select(item);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }

        this.state = state;
      }
    }, {
      key: "dispatchAction",
      value: function dispatchAction(action, keyword) {
        this.dispatch({
          type: action,
          keyword: keyword
        });
      }
    }, {
      key: "add",
      value: function add(keyword) {
        if (!this.state.keywords.has(keyword.value)) {
          this.dispatchAction("addKeyword", keyword);
        }
      }
    }, {
      key: "remove",
      value: function remove(keyword) {
        if (this.state.keywords.has(keyword.value)) {
          this.dispatchAction("removeKeyword", keyword);
        }
      }
    }, {
      key: "_setupOptions",
      value: function _setupOptions(options) {
        var opts = options || {};
        opts.prevKeys = this._normalizeKeyOptions(opts.prevKeys, [38]);
        opts.nextKeys = this._normalizeKeyOptions(opts.nextKeys, [40]);
        opts.selectKeys = this._normalizeKeyOptions(opts.selectKeys, [13, 32]);
        this.options = opts;
      }
    }, {
      key: "_normalizeKeyOptions",
      value: function _normalizeKeyOptions(keys, defaults) {
        if (!Array.isArray(keys)) {
          keys = keys ? [keys] : defaults;
        }

        return keys.map(function (k) {
          return typeof k === "string" && !Number(k) ? k.charCodeAt(0) : Number(k);
        });
      }
    }, {
      key: "_clearTabIndexes",
      value: function _clearTabIndexes() {
        var tabindexes = this.listbox.querySelectorAll("[tabindex]");

        for (var index = 0; index < tabindexes.length; index++) {
          tabindexes[index].removeAttribute("tabindex");
        }
      }
    }, {
      key: "_clearAllSelectedItems",
      value: function _clearAllSelectedItems() {
        var items = this.listbox.querySelectorAll("[aria-selected=true]");

        for (var index = 0; index < items.length; index++) {
          items[index].setAttribute("aria-selected", "false");
        }
      }
    }, {
      key: "_handleClick",
      value: function _handleClick(event) {
        event.preventDefault();

        var optionEl = this._optionNode(event);

        if (optionEl) {
          this._select(optionEl);
        }
      }
    }, {
      key: "_handleKeydown",
      value: function _handleKeydown(event) {
        var optionEl = this._optionNode(event),
            code = event.keyCode || event.code;

        if (!optionEl) {
          return;
        }

        if (this.options.selectKeys.indexOf(code) !== -1) {
          this._select(optionEl);
        } else if (event.target && event.target.getAttribute("role") === "option") {
          this._handleKey(optionEl, code, this.options.nextKeys, 1);

          this._handleKey(optionEl, code, this.options.prevKeys, -1);
        }
      }
    }, {
      key: "_handleKey",
      value: function _handleKey(optionEl, code, keys, delta) {
        if (keys.indexOf(code) !== -1) {
          var optionEls = this.listbox.querySelectorAll('[role="option"]:not([aria-disabled="true"])'),
              idx = Array.prototype.indexOf.call(optionEls, optionEl);
          var next = optionEls[idx + delta];

          if (next) {
            this._clearTabIndexes();

            next.setAttribute("tabindex", 0);
            next.focus();
          }
        }
      }
    }, {
      key: "_mount",
      value: function _mount() {
        var firstSelected = this.listbox.querySelector('[aria-selected="true"]');

        if (firstSelected) {
          firstSelected.setAttribute("tabindex", "0");
        } else {
          var options = this.listbox.querySelectorAll('[role="option"]:not([aria-disabled="true"])');

          if (options.length) {
            options[0].setAttribute("tabindex", 0);
          }
        }

        this.listbox.addEventListener("click", this._handleClick);
        this.listbox.addEventListener("keydown", this._handleKeydown);
      }
    }, {
      key: "_select",
      value: function _select(child) {
        if (child.getAttribute("aria-disabled") === "true") {
          return;
        }
        var multiselect = this.listbox.getAttribute("aria-multiselectable") === "true";

        if (!multiselect) {
          this._clearAllSelectedItems();
        }

        if (multiselect && child.getAttribute("aria-selected") === "true") {
          //! Si click sur un élément déjà sélectionné. La suppression se fait uniquement dans la liste des mots-clés en selection (keywordSelected)
          return; // child.removeAttribute("aria-selected");
          // this.remove({ value: child.dataset.value, label: child.dataset.label });
        } else {
          this._clearTabIndexes();

          child.setAttribute("aria-selected", "true");
          child.setAttribute("tabindex", "0");
          child.focus();

          if (multiselect) {
            this.add({
              value: child.dataset.value,
              label: child.dataset.label
            });
          }
        }
      }
    }, {
      key: "_optionNode",
      value: function _optionNode(event) {
        var optionEl = event.target;

        while (optionEl && optionEl.getAttribute("role") !== "option") {
          optionEl = optionEl.parentElement;
        }

        return optionEl;
      }
    }]);

    return Keyword;
  }();

  // TODO : Ajouter un role Listbox sur le html + gestion du focus ?

  var KeywordSelected = /*#__PURE__*/function () {
    function KeywordSelected(state, _ref) {
      var _this = this;

      var container = _ref.container,
          dispatch = _ref.dispatch;

      _classCallCheck(this, KeywordSelected);

      this.state = state;
      this.dispatch = dispatch;
      this.container = container.querySelector("#KeywordSelected");
      this._deleteListener = this._deleteEvent.bind(this);
      this.container.addEventListener("animationstart", function () {
        _this.dispatch({
          type: "updateSearchboxHeight",
          searchboxHeight: null
        });
      });
    }

    _createClass(KeywordSelected, [{
      key: "syncState",
      value: function syncState(state) {
        if (state.keywordsSelected.size !== this.state.keywordsSelected.size) {
          this.state = state;

          if (state.keywordsSelected.size > 0) {
            this.updateKeywordSelectedList();
          }
        }

        this.state = state;
      }
    }, {
      key: "updateKeywordSelectedList",
      value: function updateKeywordSelectedList() {
        // récupérer ou créer <ul>
        var list = this.getUL(); // Avant d'afficher tous les mots-clés demandés,
        // supprimer ceux déjà présents

        var listItems = list.querySelectorAll("li");

        for (var index = 0; index < listItems.length; index++) {
          this.removeKeyword(listItems[index], false);
        } //


        var _iterator = _createForOfIteratorHelper(this.state.keywordsSelected),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                val = _step$value[1];

            var keyword = this.addKeyword(key, val);
            list.appendChild(keyword);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.dispatch({
          type: "updateKeywordSelectedList"
        });
      }
    }, {
      key: "dispatchAction",
      value: function dispatchAction(action, keyword) {
        this.dispatch({
          type: action,
          keyword: keyword
        });
      }
    }, {
      key: "getUL",
      value: function getUL() {
        var ul = this.container.firstElementChild;

        if (!ul) {
          ul = document.createElement("ul");
          ul.className = config.keywords.ulClassName;
          this.container.appendChild(ul);
        }

        return ul;
      }
    }, {
      key: "addKeyword",
      value: function addKeyword(value, label) {
        var li = this._addMarkupLi(value, label);

        return li;
      }
    }, {
      key: "removeKeyword",
      value: function removeKeyword(el, removeParent) {
        var parent = el.parentNode;
        el.querySelector("." + config.keywords.tooltipClassName); // Si un tooltip est présent, supprimer l'instance tippy

        el.remove();

        if (removeParent && !parent.firstElementChild) {
          parent.remove();
          this.dispatch({
            type: "updateSearchboxHeight",
            searchboxHeight: null
          });
        }
      }
    }, {
      key: "_deleteEvent",
      value: function _deleteEvent(event) {
        var btn = event.target;
        btn.removeEventListener("click", this._deleteListener);
        var keywordElement = btn.parentElement;
        this.removeKeyword(keywordElement, true);
        var keyword = {
          value: keywordElement.dataset.value,
          label: keywordElement.dataset.label
        };
        this.dispatchAction("removeKeywordSelected", keyword);
      }
    }, {
      key: "_addMarkupLi",
      value: function _addMarkupLi(value, label) {
        // <li>
        var li = document.createElement("li"); // li.class

        var liClassFrag1 = config.keywords.liClassName.main;
        var liClassFrag2 = config.keywords.liClassName.variant; // La clé du mot-clé permet de déterminer
        // l'icone de la catégorie à afficher

        var key = value.split(":");
        var category;

        switch (key[0]) {
          case "id_association":
            category = "-org";
            break;

          case "id_adresse":
            category = "-city";
            break;

          case "id_mot":
            category = "-activity";
        }

        var liClassName = liClassFrag1;
        liClassName += " " + liClassFrag1 + category;
        liClassName += " " + liClassFrag2;
        li.className = liClassName; // li dataset

        li.dataset.value = value;
        li.dataset.label = label; // span

        var span = document.createElement("span");
        span.className = config.keywords.labelClassName;
        label = this._truncateLabel(label);
        span.appendChild(document.createTextNode(label.text)); // Si le texte de l'intitulé est partiel, on ajoute un attribut alt.
        // Puis, ajout un bouton pour afficher un tooltip (avec la lib Tippy.js)

        var tooltip = null;

        if (label.alt.length > 0) {
          span.setAttribute("data-tippy-content", label.alt);
          tooltip = document.createElement("button");
          tooltip.className = "o-btn " + config.keywords.tooltipClassName;
        } // <button>


        var btn = document.createElement("button");
        btn.className = "o-btn " + config.keywords.btnDeleteClassName;
        btn.setAttribute("aria-label", "Supprimer ce critère de recherche");
        btn.addEventListener("click", this._deleteListener); // Ajouter à la balise li :
        // le span, le bouton supprimer et éventuellement le bouton tootip

        li.appendChild(span);

        if (tooltip) {
          li.appendChild(tooltip); // tippy(tooltip, {
          //     content: label.alt,
          //     theme: "ata-light-border",
          //     placement: "bottom",
          //     hideOnClick: false,
          // });
        }

        li.appendChild(btn);
        return li;
      } // Tronquer un intitulé excédent un nombre de caractères défini

    }, {
      key: "_truncateLabel",
      value: function _truncateLabel(label) {
        // longueur maximum des intitulés de mots-clés
        var maxLength = 15;
        var alt = "";

        if (label.length > maxLength) ;

        return label = {
          text: label,
          alt: alt
        };
      }
    }]);

    return KeywordSelected;
  }();

  function _empty() {}

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  }

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var Modal = /*#__PURE__*/function () {
    function Modal(state, _ref) {
      var container = _ref.container,
          dispatch = _ref.dispatch;

      _classCallCheck(this, Modal);

      this.state = state;
      this.dispatch = dispatch;
      this.atlasContainer = container;
      this.modals = {};
      this.memory = {
        modalAssociation: {
          position: "",
          btns: [],
          transitions: {
            transitionOn: "",
            transitionOnPreview: "",
            transitionOff: ""
          }
        },
        modalRecherche: {
          position: "",
          btns: [],
          transitions: {
            transitionOn: "",
            transitionOnPreview: null,
            transitionOff: ""
          }
        },
        previewHeight: "",
        bottomBarHeight: "",
        working: false
      };
      this.setUpModal();
      this._handlerClickBtns = this.handlerClickBtns.bind(this);
      this._handlerClickList = this.handlerClickList.bind(this);
    }

    _createClass(Modal, [{
      key: "syncState",
      value: function syncState(state) {
        if (state.modalAction === "addModalContent") {
          this.addContent(state);
        } else if (state.modalAction === "closeModals") {
          this.closeAllModals();
        } else if (state.windowWidth === "desktop" && state.windowWidth === this.state.windowWidth && state.searchboxHeight !== this.state.searchoxHeight && (this.state.modalAssociation === "openedFull" || this.state.modalRecherche === "openedFull")) {
          this.updateLayout(state.searchboxHeight);
        }

        this.state = state;
      }
    }, {
      key: "addContent",
      value: function addContent(state) {
        try {
          var _this2 = this;

          var modalId = state.modalId;
          var args, history;

          if (state.modalOpenId) {
            args = {
              id_gis: state.modalOpenId
            };
            history = true;
          } else if (state.modalArgs) {
            args = {
              id_association: state.modalArgs.id_association
            };
            history = false;
          }
          /* Fermer la modale si elle est déjà ouverte */


          return _invoke(function () {
            if (_this2.memory[modalId].position !== "closed") {
              return _awaitIgnored(_this2.close(modalId, true));
            }
          }, function () {
            return _invoke(function () {
              if (modalId === "modalRecherche" && _this2.memory.modalAssociation.position !== "closed") {
                return _awaitIgnored(_this2.close("modalAssociation", true));
              }
            }, function () {
              /* Charger le contenu via ajaxReload et ouvrir via le callback */
              var openCallback = function openCallback() {
                /* Memoriser le nouveau contenu */
                var modal = _this2.atlasContainer.querySelector("#" + modalId);

                _this2.modals[modalId] = modal;
                /* Ajouter les gestionnaires d'événements */

                _this2.bindListeners(modalId);
                /* Position et transitions */


                _this2.setPosition(modalId);

                if (modalId === "modalRecherche" && _this2.state.windowWidth === "mobile") {
                  // Ouvrir seulement la barre en bas de fenêtre
                  _this2.toggleVisibility(modalId);
                } else {
                  // Ouvrir la modale
                  _this2.open(modalId, true);
                }
              };

              window.ajaxReload(modalId, {
                callback: openCallback,
                args: args,
                history: history
              });
            });
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    }, {
      key: "closeAllModals",
      value: function closeAllModals() {
        this.memory.working = true;

        for (var key in this.modals) {
          var modalId = this.modals[key].id;

          if (this.memory[modalId].position !== "closed") {
            this.close(modalId, true);
          }
        }

        if (this.state.windowWidth === "mobile") {
          this.memory.bottomBarHeight = "";
          this.dispatch({
            type: "moveZoom",
            height: 0
          });
        }

        this.memory.working = false;
      }
    }, {
      key: "close",
      value: function close(modalId, bool) {
        try {
          var _this4 = this;

          var modal = _this4.modals[modalId];
          var toggleAria = typeof bool === "undefined" ? true : bool;
          var moveZoom;

          if (!toggleAria && modalId === "modalRecherche" && _this4.state.windowWidth === "mobile") {
            modal = modal.firstElementChild.firstElementChild;
            toggleAria = false;
          }

          _this4.memory.working = true;
          return _await(_this4.closeTransition(modal, _this4.memory[modalId].transitions.transitionOff, toggleAria), function () {
            if (toggleAria) {
              _this4.memory[modalId].position = "closed";

              _this4.unbindListeners(modalId);

              if (_this4.state.windowWidth === "mobile" && _this4.memory.modalRecherche.position === "closed") {
                _this4.dispatch({
                  type: "moveZoom",
                  height: 0
                });
              }
            } else {
              _this4.memory[modalId].position = "visible";
            }

            _this4.memory.working = false;
            return modal;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    }, {
      key: "open",
      value: function open(modalId, bool) {
        try {
          var _this6 = this;

          var modal = _this6.modals[modalId];
          var toggleAria = typeof bool === "undefined" ? true : bool;
          var transition, btnToggleClass, moveZoom; // Selon la modale et la largeur de la fenêtre, le bloc à manipuler n'est pas le même.

          if (modalId === "modalRecherche" && _this6.state.windowWidth === "mobile") {
            modal = modal.firstElementChild.firstElementChild;
            toggleAria = false;
            moveZoom = _this6.memory.bottomBarHeight;
          }

          if (_this6.memory[modalId].position === "openedPreview") {
            transition = _this6.memory[modalId].transitions.transitionOnPreview;
            btnToggleClass = "is-toggle-up";

            if (_this6.memory.modalRecherche.position === "closed") {
              moveZoom = _this6.memory.previewHeight;
            }
          } else {
            transition = _this6.memory[modalId].transitions.transitionOn;
            btnToggleClass = "is-toggle-down";
          }

          _this6.memory.working = true;
          return _await(_this6.openTransition(modal, transition, toggleAria), function () {
            _this6.memory[modalId].btns.forEach(function (btn) {
              btn.classList.add("is-ready-to-animate");

              if (btn.dataset.modalAction === "toggle") {
                btn.classList.add(btnToggleClass);
              }
            });

            if (typeof moveZoom !== "undefined") {
              _this6.dispatch({
                type: "moveZoom",
                height: moveZoom
              });
            }

            _this6.memory.working = false;
            return modal;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    }, {
      key: "toggleVisibility",
      value: function toggleVisibility(modalId) {
        var modal = this.modals[modalId];

        if (modal.getAttribute("aria-hidden") === "false") {
          modal.setAttribute("aria-hidden", "true");
          this.memory[modalId].position = "closed";
        } else {
          modal.setAttribute("aria-hidden", "false");
          this.memory[modalId].position = "visible";
          this.dispatch({
            type: "moveZoom",
            height: this.memory.bottomBarHeight
          });
        }
      }
    }, {
      key: "bindListeners",
      value: function bindListeners(modalId) {
        var _this7 = this;

        var modal = this.modals[modalId];
        var btns = modal.querySelectorAll("button");
        this.memory[modalId].btns = btns;
        btns.forEach(function (btn) {
          btn.addEventListener("click", _this7._handlerClickBtns);
          btn.setAttribute("tabindex", "0");

          if (modalId === "modalAssociation") {
            _this7.setAnimationBtn(btn);
          }
        });

        if (modalId === "modalRecherche") {
          var list = modal.querySelectorAll("li");
          this.memory[modalId].list = list;
          list.forEach(function (item) {
            item.addEventListener("click", _this7._handlerClickList);
          });
        }
      }
    }, {
      key: "unbindListeners",
      value: function unbindListeners(modalId) {
        var _this8 = this;

        var btns = this.memory[modalId].btns;
        btns.forEach(function (btn) {
          btn.removeEventListener("click", _this8._handlerClickBtns);
          btn.setAttribute("tabindex", "-1");
        });
        var list = this.memory[modalId].list;

        if (typeof list !== "undefined" && list.length > 0) {
          list.forEach(function (item) {
            item.removeEventListener("click", _this8._handlerClickList);
          });
        }
      } ///\\\

    }, {
      key: "calcBottomBarHeight",
      value: function calcBottomBarHeight(modal) {
        var bottomBar = modal.querySelector("." + config.modal.bottomBarClass);
        return -Math.abs(bottomBar.offsetHeight);
      }
    }, {
      key: "calcPreviewHeight",
      value: function calcPreviewHeight(modal) {
        var body = modal.querySelector("article h2");
        var previewHeight = -Math.abs(body.nextElementSibling.offsetTop + 36);
        return previewHeight;
      }
    }, {
      key: "getModals",
      value: function getModals() {
        var modals = this.atlasContainer.querySelectorAll("[data-modal]");
        return modals;
      }
    }, {
      key: "handlerClickBtns",
      value: function handlerClickBtns(event) {
        var btn = event.target;
        var modal = event.target.closest("[data-modal]");
        var modalId = modal.id;
        var action = event.target.dataset.modalAction; // position demandée

        var position = this.memory[modalId].position;

        if (modal.id === "modalRecherche" && action === "toggle") {
          if (this.memory.working) {
            return;
          } // Manipuler le texte du bouton


          if (btn.getAttribute("data-text-toggle") == btn.innerHTML) {
            btn.innerHTML = btn.getAttribute("data-text-original");
          } else {
            btn.setAttribute("data-text-original", btn.innerHTML);
            btn.innerHTML = btn.getAttribute("data-text-toggle");
          } // Si position "visible", alors seule la barre en bas de la fenêtre est visible.
          // sinon position "openedFull".


          if (position === "visible") {
            this.memory[modalId].position = "openedFull";
            this.open(modalId, false);
          } else {
            this.memory[modalId].position = "visible";
            this.close(modalId, false);
          }
        } else if (modal.id === "modalAssociation") {
          if (this.memory.working) {
            return;
          }

          if (action === "toggle" && position === "openedPreview") {
            this.memory[modalId].position = "openedFull";
            this.open(modalId, false);
          } else {
            this.close(modalId, true);
          }
        }
      }
    }, {
      key: "handlerClickList",
      value: function handlerClickList(event) {
        var li = event.target.closest("[data-id-gis]");

        if (li) {
          this.dispatch({
            type: "addModalContent",
            openId: li.dataset.idGis,
            modalId: "modalAssociation"
          });
          this.dispatch({
            type: "centerOnMarker",
            coords: [li.dataset.lon, li.dataset.lat],
            id: li.dataset.idGis
          });
        }
      }
    }, {
      key: "openTransition",
      value: function openTransition(el, transition, bool) {
        return new Promise(function (resolve) {
          if (bool) {
            el.setAttribute("aria-hidden", "false");
          }

          el.addEventListener("transitionend", function _f() {
            resolve(el);
            this.removeEventListener("transitionend", _f);
          });
          el.style.transform = transition;
        });
      }
    }, {
      key: "closeTransition",
      value: function closeTransition(el, transition, bool) {
        return new Promise(function (resolve) {
          el.addEventListener("transitionend", function _f() {
            if (bool) {
              el.setAttribute("aria-hidden", "true");
            }

            el.style.transform = "";
            resolve(el);
            this.removeEventListener("transitionend", _f);
          });
          el.style.transform = transition;
        });
      }
    }, {
      key: "setAnimationBtn",
      value: function setAnimationBtn(button) {
        var circle = button.querySelector("circle");

        if (circle) {
          var circumference = (2 * Math.PI * circle.getAttribute("r")).toFixed(2);
          circle.setAttribute("stroke-dashoffset", circumference);
          circle.setAttribute("stroke-dasharray", circumference);
        }
      }
      /*
          Définir position et transitions en fonction de la modale à ouvrir
          et en fonction de la largeur de la fenêtre.
       */

    }, {
      key: "setPosition",
      value: function setPosition(modalId) {
        var modal = this.modals[modalId];
        var position, transitions;

        if (this.state.windowWidth === "desktop") {
          this.updateLayout(this.state.searchboxHeight);
          position = "openedFull";
          transitions = this.setStyleTransitions(this.state.windowWidth);
        } else {
          if (modalId === "modalAssociation") {
            position = "openedPreview";
            this.memory.previewHeight = this.calcPreviewHeight(modal);
            transitions = this.setStyleTransitions(this.state.windowWidth);
          } else {
            position = "openedFull";
            transitions = this.setStyleTransitions(this.state.windowWidth);
            this.memory.bottomBarHeight = this.calcBottomBarHeight(modal);
          }
        }

        this.memory[modalId].position = position;
        this.memory[modalId].transitions = transitions;
      }
    }, {
      key: "setStyleTransitions",
      value: function setStyleTransitions(windowWidth) {
        var transitions = {};

        if (windowWidth === "desktop") {
          transitions.transitionOn = "translateX(0)";
          transitions.transitionOnPreview = null;
          transitions.transitionOff = "translateX(-100%)";
        } else {
          if (this.memory.previewHeight) {
            transitions.transitionOnPreview = "translateY(" + this.memory.previewHeight + "px)";
          } else {
            transitions.transitionOnPreview = null;
          }

          transitions.transitionOn = "translateY(-100%)";
          transitions.transitionOff = "translateY(0)";
        }

        return transitions;
      }
    }, {
      key: "setTabIndex",
      value: function setTabIndex(el, bool) {
        if (bool) {
          el.setAttribute("tabindex", "-1");
        } else {
          el.removeAttribute("tabindex");
        }
      }
    }, {
      key: "setUpModal",
      value: function setUpModal() {
        var _this9 = this;

        var modals = this.getModals();

        if (modals) {
          modals.forEach(function (modal) {
            var modalId = modal.id;
            _this9.modals[modalId] = modal;

            if (modal.classList.contains(config.modal.openedClass)) ; else {
              modal.setAttribute("aria-hidden", "true"); // modal.classList.add(config.modal.closedClass);

              _this9.setTabIndex(modal, true);

              _this9.memory[modalId].position = "closed";
            }
          });
        }
      }
      /*
      Si la fenêtre du navigateur est en position "desktop",
      on ajoute une marge intérieure qui varie selon la hauteur
      du module Searchbox.
      */

    }, {
      key: "updateLayout",
      value: function updateLayout(value) {
        for (var key in this.modals) {
          var innerDiv = this.modals[key].firstElementChild.firstElementChild;
          innerDiv.style.paddingTop = value + "px";
        }
      }
    }]);

    return Modal;
  }();

  var atlas;
  var state = {
    windowWidth: null,
    searchboxHeight: null,
    keywords: new Map(),
    keywordsSelected: new Map(),
    modalAction: "",
    modalArgs: {},
    modalOpenId: "",
    modalId: "",
    centerMarker: {},
    moveZoom: ""
  };

  var init = function init(leafletmap) {
    var conf = {
      containerId: "atlas",
      controls: [SearchBox, Keyword, KeywordSelected, Modal],
      dispatch: function dispatch(action) {
        state = atlas.handleAction(state, action);
        atlas.syncState(state);
      }
    };
    atlas = new AtlasBase(leafletmap, state, conf); // compléter state.windowWidht et state.searchboxHeight

    atlas.setInitialState();
  };

  var addKeyword = function addKeyword(keyword) {
    atlas.autocompleteAddKeyword(keyword);
  };

  exports.addKeyword = addKeyword;
  exports.init = init;

  return exports;

}({}));
